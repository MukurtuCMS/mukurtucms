<?php
/**
 * @file
 * Code for the Digital Heritage Metadata Import feature.
 */

include_once('ma_digitalheritage.features.inc');

/**
 * Implements hook_node_presave().
 */
function ma_digitalheritage_node_presave($node) {
  if ($node->type == 'digital_heritage') {

    // Set the community record parent if the session var for such was set in ma_digitalheritage_form_digital_heritage_node_form_alter
    if (isset ($_SESSION['community_record_parent']) && isset($_SESSION['community_record_parent_requesting_path'])) {
      // Check and see if the previous page we were on matches the requesting page.  We don't want to set the parent on the wrong
      // node if the user navigated away from the new community record page.
      $previous_page = drupal_get_destination();
      if ($previous_page['destination'] == $_SESSION['community_record_parent_requesting_path']) {
        $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'] = $_SESSION['community_record_parent'];
        unset ($_SESSION['community_record_parent']);
        unset ($_SESSION['community_record_parent_requesting_path']);
      }
    }

  }
}

/**
 * Implements hook_node_access().
 */
function ma_digitalheritage_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  if ($type == 'digital_heritage') {
    switch ($op) {
      case 'create':
        // OG node_access doesn't know what to do for users with no community memberships yet.
        // This causes users like Language Stewards to be presented with the option to create DH items, which we don't want.
        // Get the list of CPs a user can use, if none, don't let them create DH
        $cps = module_exists('ma_culturalprotocol') ? ma_cultural_protocol_get_cps_user_can_post_to() : [];
        if (empty($cps)) {
          return NODE_ACCESS_DENY;
        }
    }

  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_node_update().
 */
function ma_digitalheritage_node_update($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);
    $dh_emw_old = entity_metadata_wrapper('node', $node->original);

    // If this is a Book Child, reindex the parent
    $book_parent = $dh_emw->field_book_parent->value();
    if (!empty($book_parent) && isset($book_parent->nid)) {
      search_api_index_specific_items_delayed(search_api_index_load('default_node_index'), [$book_parent->nid]);
    }

    // If this is a Book Parent, replicate some field values to its book children
    $book_children = $dh_emw->field_book_children->value();
    if (count($book_children)) {

      // Replicate the Protocols (if changed) (their Communities will get set in their own wrapper save below)
      if (array_values($dh_emw->og_group_ref->value()) <> array_values($dh_emw_old->og_group_ref->value())) {
        foreach ($book_children as $child_page) {
          foreach ($dh_emw->og_group_ref->value() as $protocol) {
            $parent_protocols[] = $protocol->nid;
          }
          if (count($parent_protocols)) {
            $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
            $book_child_wrapper->og_group_ref->set(array_unique($parent_protocols));
            $book_child_wrapper->save();
          }
        }
        #dpm ('groups changed on children');
      }

      // Replicate the privacy setting (if changed)
      if ($dh_emw->field_item_privacy_setting->value() <> $dh_emw_old->field_item_privacy_setting->value()) {
        foreach ($book_children as $child_page) {
          $book_child_wrapper = entity_metadata_wrapper('node', $child_page);
          $book_child_wrapper->field_item_privacy_setting->set($dh_emw->field_item_privacy_setting->value());
          $book_child_wrapper->save();
        }
        #dpm ('privacy setting changed on children');
      }

    }

    // Populate Community Records MM Field -- TW26327861
    // We work only by the parent record's children field because it always gets updated since the parent<>child records are a CER.
    if (isset($_SESSION['force_update_cr_mm_field']) && !$_SESSION['updating_mm_cr_field']) {
      $new_crs = $dh_emw->field_community_record_children->value();
      $old_crs = $dh_emw_old->field_community_record_children->value();
      if ($new_crs <> $old_crs OR $_SESSION['force_update_mm_cr_field']) {
        array_unshift($new_crs, $node); // add the parent as the first record.
        foreach ($new_crs as $cr_outer) {
          $linked_crs = [];
          foreach ($new_crs as $cr_inner) {
            // Build the title for the CR link title. This is the same as how we set the CR node title in ma_digitalheritage_node_view() and CR node tab in ma_digitalheritage_page_alter().
            $community_record_parent_communities = [];
            foreach ($cr_inner->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
              $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
              $community_record_parent_communities[] = $community_record_parent_community_node->title;
            }
            $community_record_title = implode(' / ', $community_record_parent_communities) . ' Record';
            $community_record_title = $cr_inner->nid == $cr_outer->nid ? $community_record_title . ' (currently viewing)' : $community_record_title; // append "(currently viewing)" to the link text for the current node. This is why we need the double inner and outer CR loop.
            // Save the link to our link array
            $linked_crs[] = [
              'title' => $community_record_title,
              'url' => 'node/' . $cr_inner->nid,
              'attributes' => ['muk-app' => TRUE],
            ];
          }

          // Save the links to the field.
          // Use a session var to avoid infinite loop for the parent node.
          $cr_outer->field_comm_records_mm[LANGUAGE_NONE] = $linked_crs;
          $_SESSION['updating_mm_cr_field'] = TRUE;
          node_save($cr_outer);
          $_SESSION['updating_mm_cr_field'] = FALSE;
        }
      }
    }

  }
}

/**
 * Implements hook_node_postupdate().
 *
 * If the communities are changed on either a child or parent community record,
 * then update the parent node because it's and it's children's MM CR text field needs to be updated.
 * Part of TW26327861.
 */
function ma_digitalheritage_node_postupdate($node) {
  if ($node->type == 'digital_heritage') {
    if (isset($_SESSION['force_update_cr_mm_field']) && !$_SESSION['force_update_cr_mm_field']) {
      $dh_emw = entity_metadata_wrapper('node', $node);
      $dh_emw_old = entity_metadata_wrapper('node', $node->original);
      if ($dh_emw->field_community_ref->value() <> $dh_emw_old->field_community_ref->value()) {
        $parent_cr = NULL;
        if (count($dh_emw->field_community_record_children->value())) {
          $parent_cr = $node;
        } elseif (count($dh_emw->field_community_record_parent->value())) {
          $parent_cr = $dh_emw->field_community_record_parent->value();
        }
        if ($parent_cr) {
          $_SESSION['force_update_mm_cr_field'] = TRUE;
          node_save($parent_cr);
          $_SESSION['force_update_mm_cr_field'] = FALSE;
        }
      }
    }
  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_views_exposed_form_alter(&$form, &$form_state) {

  // Add a button to reset search and filters
  // Search API provides a button on the view that will reset the search, but not the filters. Leaving that off and creating our own that will reset both.
  if (strpos($form['#id'], 'views-exposed-form-digital-heritage-grid-list') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = [
        '#markup' => l(t('Reset'), 'digital-heritage', [
          'attributes' => [
            'class' => [
              'btn',
              'btn-primary',
              'form-submit',
            ],
          ],
          'html' => TRUE,
        ]),
      ];
    }
  }
  if (strpos($form['#id'], 'views-exposed-form-browse-all-content-all') !== FALSE) {
    if (count(arg()) > 1 OR count(drupal_get_query_parameters())) {
      $form['reset'] = [
        '#markup' => l(t('Reset'), 'browse', [
          'attributes' => [
            'class' => [
              'btn',
              'btn-primary',
              'form-submit',
            ],
          ],
          'html' => TRUE,
        ]),
      ];
    }
  }

}


/**
 * Implements moduleName_preprocess_hook.
 */
function ma_digitalheritage_preprocess_page(&$variables) {
  if (isset($variables['node']) && $variables['node']->type == 'digital_heritage') {
    // For digital heritage items, remove the standard local tasks tab.
    unset($variables['tabs']);
  }
}

/**
 * Implements template_preprocess_field.
 */
function ma_digitalheritage_preprocess_field(&$variables, $hook) {
  // Display the first image or thumbnail when viewing the media asset field rather than a default icon for any display where we are
  // showing a single image to represent the entire field (e.g., search results). This was previously implemented as a patch to Scald.
  if ($variables['element']['#field_name'] == 'field_media_asset' && $variables['element']['#view_mode'] == 'search_result') {
    // Only process if there are more than 1 scald atoms
    if (isset($variables['element']['#object']->field_media_asset[LANGUAGE_NONE]) && count($variables['element']['#object']->field_media_asset[LANGUAGE_NONE]) > 1) {
      // Search through the scald atoms and find the first image or thumbnail
      foreach ($variables['element']['#object']->field_media_asset[LANGUAGE_NONE] as $index => $item) {
        $atom = scald_atom_load($item['sid']);

        if ($atom && ($atom->type == 'image' || isset($atom->scald_thumbnail[LANGUAGE_NONE][0]))) {
          if ($index == 0) {
            break;
          }
          // Move image to first position
          $temp = $variables['items'][$index];
          unset($variables['items'][$index]);
          array_unshift($variables['items'], $temp);
          break;
        }
      }
    }
  }

  // Show only one media item in teaser. We really need to make a standalone display formatter for this.
  $single_media_view_modes = ['teaser', 'search_result'];
  if (in_array($variables['element']['#view_mode'], $single_media_view_modes)) {
    if ($variables['element']['#field_name'] == 'field_media_asset') {
      if (count($variables['element']['#items']) > 1) {
        $first_media = FALSE;
        foreach ($variables['items'] as $item_key => $item) {
          if (!$first_media) {
            $first_media = TRUE;
          }
          else {
            unset($variables['items'][$item_key]);
          }
        }
      }
    }
  }

  if ($variables['element']['#field_name'] == 'field_transcription') {
    // Convert newlines in transcription fields to html if plain text only
    if (!isset($variables['element']['#items'][0]['format']) && isset($variables['element']['#items'][0]['safe_value'])) {
      $variables['items'][0]['#markup'] = nl2br($variables['items'][0]['#markup']);
    }
  }
}

/**
 * Implements hook_views_pre_render().
 */
function ma_digitalheritage_views_pre_render(&$view) {
  // Display the first image or thumbnail in the related items teaser rather than the default audio/file/video icon
  if ($view->name == 'dh_related_items_teasers' && isset($view->result[0]->_field_data['nid']['entity']->field_media_asset[LANGUAGE_NONE])) {
    // Search through the scald atoms for the first image or thumbnail
    foreach ($view->result[0]->_field_data['nid']['entity']->field_media_asset[LANGUAGE_NONE] as $index => $item) {
      $atom = scald_atom_load($item['sid']);

      // Found it, render that instead
      if ($atom->type == 'image' || isset($atom->scald_thumbnail[LANGUAGE_NONE][0])) {
        $image_atom = scald_render($atom, 'mukurtu_scald_related_items');
        $view->result[0]->field_field_media_asset[0]['rendered']['#markup'] = $image_atom;
        $view->result[0]->field_field_media_asset[0]['raw']['sid'] = $atom->sid;
        break;
      }
    }
  }
}

/**
 * Implements template_preprocess_views_view.
 */
function ma_digitalheritage_preprocess_views_view(&$vars) {
  $view = &$vars['view'];

  if ($view->name == 'digital_heritage_grid_list' || $view->name == 'browse_all_content') {
    // Add JS for browse mode switcher on DH view
    drupal_add_library('system', 'jquery.cookie');
    drupal_add_js(drupal_get_path('module', 'ma_digitalheritage') . '/js/dh_browse_mode_switcher.js');

    // If none of the resultant DH items have geofield data, don't show map view as an option
    $remove_map_browse = TRUE;

    if (isset($view->result)) {
      foreach ($view->result as $search_result) {
        $dh_node = node_load($search_result->entity);
        if (isset($dh_node->field_coverage['und'][0]['geom'])) {
          $remove_map_browse = FALSE;
          break;
        }
      }
    }

    if (isset($vars['header']) && $remove_map_browse) {
      $vars['header'] = str_replace('<a class="map btn">Map</a>', '', $vars['header']);
    }
  }
}

/**
 * Implements hook_user_logout().
 */
// Delete the cookie that holds the DH browse mode setting
function ma_digitalheritage_user_logout($account) {
  setcookie('dh_browse_mode', '', 1, '/');
}

/**
 * Implementation of hook_node_view().
 */
function ma_digitalheritage_node_view($node, $view_mode) {

  if ($node->type == 'digital_heritage') {

    // Ensure these get reset on node views. This handling is only for during submission.
    // Part of TW26327861
    $_SESSION['force_update_mm_cr_field'] = FALSE;
    $_SESSION['updating_mm_cr_field'] = FALSE;

    if ($view_mode == 'full') {

      // Users (especially new admins) are sometimes viewing community records independently of the parent record and getting confused
      // because they think it is a standalone record.  Add a link back to the parent record to avoid confusion.
      // Only show to users with edit rights, only concerned about unintentional edits.
      $current_page_node = menu_get_object();
      $current_page_nid = isset($current_page_node) ? $current_page_node->nid : 0;
      if (!empty($node->field_community_record_parent) && ($current_page_nid != $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'])) {
        $parent_record = node_load($node->field_community_record_parent[$node->language][0]['target_id']);
        if ($parent_record && node_access('update', $node)) {

          // Form community name title for the label
          $community_record_parent_communities = [];
          foreach ($node->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
            $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
            $community_record_parent_communities[] = $community_record_parent_community_node->title;
          }
          $community_record_title = implode(' / ', $community_record_parent_communities);

          // Link to the parent node
          $parent_link = t('This is a ') . $community_record_title . t(' community record of ') . l($parent_record->title, 'node/' . $parent_record->nid);
          $node->content['field_media_asset'][0]['#markup'] = '<div class="alert alert-block alert-success">' . $parent_link . '</div>' . $node->content['field_media_asset'][0]['#markup'];
        }
      }
      // Hide the Related Items Teasers if the option is not selected
      if (variable_get('mukurtu_show_related_items_teasers') <> 1) {
        unset ($node->content['dh_related_items_teasers']);
      }
    }
    elseif ($view_mode == 'community_record') {

      // Add an edit link to community record after its title
      if (node_access('update', $node)) {
        $node->content['title'][0]['#markup'] = $node->title . l(' (edit)', 'node/' . $node->nid . '/edit');
      }
    }

  }

}

/**
 * Implements hook_comment_insert().
 */
function ma_digitalheritage_comment_insert($comment) {

  // Notify protocol steward(s) when a comment has been posted to one of their Cultural Protocols that requires approval
  if ($comment->node_type == 'comment_node_digital_heritage') {
    if ($comment->status) {
      return;
    } // comment is pre-approved (eg. posted by admin)
    $dh_emw = entity_metadata_wrapper('node', $comment->nid);

    // Build the array of protcol manager emails from the protocol steward(s) of the given protocol(s) for this DH node
    if ($cps = $dh_emw->og_group_ref->value()) {
      $protocol_managers_emails = [];
      foreach ($cps as $cp) {
        $cp_emw = entity_metadata_wrapper('node', $cp);
        if ($protocol_managers = ma_core_og_get_users_per_role_and_group('protocol steward', 'cultural_protocol_group', $cp->nid)) {
          foreach ($protocol_managers as $protocol_manager) {
            $protocol_managers_emails[] = $protocol_manager->name . ' <' . $protocol_manager->mail . '>';
          }
        }
      }

      // Send the email (the body and subject get built in ma_digitalheritage_mail)
      if (count($protocol_managers_emails)) {
        $params = [
          'comment' => $comment,
          'cp_emw' => $cp_emw,
          'dh_emw' => $dh_emw,
          'recipient_count' => count($protocol_managers_emails),
        ];
        drupal_mail('ma_digitalheritage', 'dh_comment_notification', implode(', ', $protocol_managers_emails), language_default(), $params);
      }
    }
  }
}

/*
 * Implementation of hook_mail().
*/
function ma_digitalheritage_mail($key, &$message, $params) {
  switch ($key) {
    case 'dh_comment_notification':
      $comment = $params['comment'];
      $cp_title = $params['cp_emw']->title->value();

      // Set the email subject
      $message['subject'] = "A comment in '" . $cp_title . "' requires your approval";

      // Set the email body
      $email_body = "A comment has been posted that requires your approval.\n\n";
      $email_body .= "Cultural Protocol:\n" . $cp_title . "\n\n";
      $email_body .= "Digital Heritage:\n" . $params['dh_emw']->title->value() . "\n\n";
      $comment_author = user_load($comment->uid);
      $email_body .= "Comment author:\n" . $comment_author->name . "\n\n";
      if ($comment->subject) {
        $email_body .= "Comment subject:\n" . $comment->subject . "\n\n";
      }
      $comment_body = $comment->comment_body[LANGUAGE_NONE][0]['value'];
      $comment_body = drupal_html_to_text($comment_body);
      $email_body .= "Comment body:\n" . $comment_body . "\n\n";
      $email_body .= "Click " . l('here', 'node/' . $comment->nid, ['fragment' => 'comment-' . $comment->cid]) . " to approve or delete this comment";
      if ($params['recipient_count'] > 1) {
        $email_body .= " (more than one Protocol Stewards have received this notification, so the comment may already be approved or deleted at this time)";
      }
      $email_body .= ".";
      $message['body'][] = $email_body;

      break;
  }
}

/**
 * Implements hook_views_pre_build().
 */
function ma_digitalheritage_views_pre_build(&$view) {

  // Override the "View All" (DH Items) path to the sapi page
  if ($view->name == 'community_dh_items') {
    $view->override_path = 'digital-heritage/' . $view->current_display;
  }
}

/**
 * Implements hook_menu().
 */
function ma_digitalheritage_menu() {
  $items = [];

  // "Duplicate Item" button for DH node
  $items['node/%node/duplicate-item'] = [
    'title' => 'Duplicate Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => ['ma_digitalheritage_clone_dh_form', 1],
    'access callback' => 'ma_digitalheritage_clone_dh_button_check',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  ];

  // "Add Community Record" button for DH node
  $items['node/%node/add-community-record'] = [
    'title' => 'Add Community Record',
    'page callback' => 'ma_digitalheritage_add_community_record',
    'page arguments' => [1],
    'access callback' => 'ma_digitalheritage_add_cr_check',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  ];

  // "Add a Book Page" button for DH node
  $items['node/%node/add-book-page'] = [
    'title' => 'Add a Book Page',
    'page callback' => 'ma_digitalheritage_add_book_page',
    'page arguments' => [1],
    'access callback' => 'ma_digitalheritage_add_book_page_check',
    'access arguments' => [1],
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  ];

  // Callback that toggles the display of the Related Items teasers
  $items['admin/toggle-related-items-teasers'] = [
    'title' => 'Toggle Related Items Teasers',
    'page callback' => 'ma_digitalheritage_toggle_related_items_teasers',
    'access arguments' => ['administer site configuration'],
    'type' => MENU_CALLBACK,
    'weight' => 100,
  ];

  return $items;
}

function ma_digitalheritage_clone_dh_button_check($node) {
  if ($node->type == 'digital_heritage' && empty($node->field_community_record_parent)) {
    $dh_emw = entity_metadata_wrapper('node', $node);
    if ($dh_emw->field_book_parent->value() OR $dh_emw->field_book_children->value()) { // Do not allow cloning or creating community records on book pages, whether child or parent
      return FALSE;
    }
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      if (isset ($protocol)) {
        $p_emw = entity_metadata_wrapper('node', $protocol);
        $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
        if (array_intersect(['protocol steward'], $roles_for_user_in_group)) {
          return TRUE;
        }
      }
    }
  }
}

function ma_digitalheritage_add_cr_check($node) {
  if ($node->type == 'digital_heritage' && empty($node->field_community_record_parent)) {
    $dh_emw = entity_metadata_wrapper('node', $node);
    foreach ($dh_emw->og_group_ref->value() as $protocol) {
      if (isset ($protocol)) {
        $p_emw = entity_metadata_wrapper('node', $protocol);
        $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
        if (array_intersect(['protocol steward'], $roles_for_user_in_group)) {
          return TRUE;
        }
      }
    }
  }
}

function ma_digitalheritage_add_book_page_check($node) {
  // Don't present the option to add a book page on community records
  if ($node->type == 'digital_heritage' && empty($node->field_community_record_parent)) {
    // Present the option to add a book page to anybody who has edit rights to the node
    return node_access("update", $node);
  }
  return FALSE;
}

function ma_digitalheritage_toggle_related_items_teasers() {
  if (variable_get('mukurtu_show_related_items_teasers')) {
    variable_set('mukurtu_show_related_items_teasers', 0);
  }
  else {
    variable_set('mukurtu_show_related_items_teasers', 1);
  }
  drupal_goto('dashboard');
}

function ma_digitalheritage_clone_dh_form($form, $form_state, $node) {
  $question = "<i>Duplicate Digital Heritage Item</i> " . $node->title;
  $description = "<div>Are you sure you want to duplicate of <i>$node->title</i>?<br><br>Community records and book pages will not be copied.</div>";
  return confirm_form($form, $question, 'node/' . $node->nid, $description);
}

function ma_digitalheritage_clone_dh_form_submit($form, $form_state) {

  // Clone the node with a new title
  $original_nid = arg(1);
  $cloned = replicate_clone_entity_by_id('node', $original_nid);
  $cloned->title = $cloned->title . ' - copy';

  // Unset any CR or book relations
  $cloned->field_community_record_children = [];
  $cloned->field_book_children = [];
  $cloned->field_book_parent = [];
  node_save($cloned);

  // Unset any CPs that the cloning protocol steward is not a contributor or protocol steward for
  $protocols_to_set = [];
  $dh_emw = entity_metadata_wrapper('node', $cloned);
  foreach ($dh_emw->og_group_ref->value() as $protocol) {
    $p_emw = entity_metadata_wrapper('node', $protocol);
    $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
    if (array_intersect([
      'protocol steward',
      'contributor',
    ], $roles_for_user_in_group)) {
      $protocols_to_set[] = $protocol;
    }
  }
  $dh_emw->og_group_ref->set($protocols_to_set);

  // Make a relationship to the original node
  $dh_emw->field_related_dh_items[] = $original_nid;

  // Save our changes
  $dh_emw->save();

  // Go to the cloned node
  drupal_set_message(t("Successfully duplicated Digital Heritage item"));
  drupal_goto('node/' . $cloned->nid);
}

// When renaming a cloned node, do not create a URL redirect from the old node, because a newly cloned node from the original node might take the original path of 1st cloned node, thus you would always be redirected to the 1st cloned node from the 2nd cloned node. This is not an edge case. It would happen in normal node cloning workflow, as it did during our tests.
function ma_digitalheritage_redirect_presave($redirect) {
  if (strpos($redirect->source, '-copy')) {
    $redirect->source = "dh_clone_redirect"; // cannot simply unset the $redirect here so setting a dummy source instead
  }
}


// "Add Community Record" button redirect to node edit form with community-record param
function ma_digitalheritage_add_community_record($node) {
  drupal_goto('node/add/digital-heritage/community-record/' . $node->nid);
}

// "Add a Book Page" button redirect to node edit form with book-page param
function ma_digitalheritage_add_book_page($node) {
  drupal_goto('node/add/digital-heritage/book-page/' . $node->nid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_digital_heritage_node_form_alter(&$form, &$form_state) {

  // Add an after build callback to tweak elements that aren't available here yet
  $form['#after_build'][] = 'ma_digitalheritage_dh_form_after_build';

  // In the Collections field, edit the title of the options to show collection ancestors.
  $form['field_collection'][LANGUAGE_NONE]['#options'] = ma_collection_add_ancestors_to_collections_titles($form['field_collection'][LANGUAGE_NONE]['#options']);

  // Prevent editing book parent
  $form['field_book_parent']['#access'] = FALSE;

  // Grab Community Record parent on node edit and set page title
  if (isset($form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0])) {
    $community_record_parent_wrapper = entity_metadata_wrapper('node', $form['field_community_record_parent'][LANGUAGE_NONE]['#default_value'][0]);

    // Set the page title
    drupal_set_title("<i>Edit Community Record</i> " . $form['#node']->title . " <i>in</i> " . $community_record_parent_wrapper->title->value(), PASS_THROUGH);
  }

  // On Community Record add, ensure the user actually has permission to create a community record on this node, in case they hacked NID in the url, and then set the community record parent wrapper and page title, and then set the session var for community record parent.
  elseif (arg(3) == 'community-record') {
    $parent_dh_wrapper = entity_metadata_wrapper('node', arg(4));
    foreach ($parent_dh_wrapper->og_group_ref->value() as $protocol) {
      $p_emw = entity_metadata_wrapper('node', $protocol);
      $roles_for_user_in_group = og_get_user_roles('node', $p_emw->getIdentifier());
      if (array_intersect(['protocol steward'], $roles_for_user_in_group)) {

        // Set the parent wrapper
        $community_record_parent_wrapper = $parent_dh_wrapper;

        // Set the page title
        drupal_set_title("<i>Create Community Record in</i> " . $community_record_parent_wrapper->title->value(), PASS_THROUGH);

        // Use a session var to set the parent community record nid. This then gets set in the child in ma_digitalheritage_node_presave. (we cannot set the field value here because it is a hidden form element)
        $_SESSION['community_record_parent'] = arg(4);

        // Also include the current path.  This will be used to verify that we are altering the correct node later
        $_SESSION['community_record_parent_requesting_path'] = current_path();
        break;
      }
    }
  }

  // Customizations to Community Record DH nodes
  if (isset($community_record_parent_wrapper)) {

    // Hide some fields
    $hide_fields = [
      'field_media_asset',
      'field_collection',
      'field_community_record_children',
    ];
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

  // Grab Book Page parent on node edit and set page title
  if (isset($form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#default_value'])) {
    $book_child_page = 1;

    // Set the page title
    $book_parent = $form['field_book_parent'][LANGUAGE_NONE][0]['target_id']['#entity'];
    drupal_set_title("<i>Edit Book Page</i> " . $form['#node']->title . " <i>in</i> " . $book_parent->title, PASS_THROUGH);
  }

  // On Book Page add, ensure the user actually has permission to create a Book Page on this node, in case they hacked NID in the url, and then set the page title, set the parent, and set the protocols and privacy setting
  elseif (arg(3) == 'book-page') {
    $referring_node = node_load(arg(4));
    global $user;
    if (ma_digitalheritage_add_book_page_check($referring_node)) { // The permission check
      $book_child_page = 1;
      if (isset ($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id'])) { // This book child page is being added from another book child page
        $book_parent = node_load($referring_node->field_book_parent[LANGUAGE_NONE][0]['target_id']);
      }
      else {
        $book_parent = $referring_node; // This book child page is being added from the parent book page
      }

      // Set the page title
      drupal_set_title("<i>Create Book Page in</i> " . $book_parent->title, PASS_THROUGH);

      // Save the parent
      $form_state['mukurtu_book_parent'] = $book_parent->nid;

      // Set the privacy setting and protocols to that of the parent
      $book_parent_wrapper = entity_metadata_wrapper('node', $book_parent);
      $form['field_item_privacy_setting'][LANGUAGE_NONE]['#value'] = $book_parent_wrapper->field_item_privacy_setting->value();
      foreach ($book_parent_wrapper->og_group_ref->value() as $protocol) {
        $form['og_group_ref'][LANGUAGE_NONE]['#default_value'][] = $protocol->nid;
      }
    }

  }

  // Customizations to Book Child Page
  if (isset($book_child_page)) {
    $hide_fields = [
      'field_item_privacy_setting',
      'field_book_children',
      'field_community_record_children',
      'field_related_dh_items',
      'field_collection',
    ];
    foreach ($hide_fields as $hide_field) {
      $form[$hide_field]['#access'] = FALSE;
    }

  }

}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_comment_node_digital_heritage_form_alter(&$form, &$form_state) {
  // Change text of DH comment submit button.
  if (isset($form['actions']['submit'])) {
    $form['actions']['submit']['#value'] = t('Save Comment');
  }
}

/**
 * After-build changes to the DH node form.
 */
function ma_digitalheritage_dh_form_after_build($form, &$form_state) {

  // Do some cleanup of the Original Date field
  unset($form['field_original_date'][LANGUAGE_NONE][0]['_separator']);
  $form['field_original_date']['und'][0]['from']['month']['#options'][''] = ''; // hide the "N/A"
  $form['field_original_date']['und'][0]['from']['day']['#options'][''] = ''; // hide the "N/A"

  return $form;
}

/**
 * Implements hook_node_submit().
 */
function ma_digitalheritage_node_submit($node, $form, &$form_state) {
  // Restore saved book parent info
  if (!empty($form_state['mukurtu_book_parent'])) {
    $book_parent = node_load($form_state['mukurtu_book_parent']);
    if ($book_parent) {
      $node->field_book_parent[LANGUAGE_NONE][0]['target_id'] = $book_parent->nid;
      $node->field_item_privacy_setting[LANGUAGE_NONE][0]['value'] = $book_parent->field_item_privacy_setting[LANGUAGE_NONE][0]['value'];
    }
  }
}

/**
 * Implements hook_node_validate().
 */
function ma_digitalheritage_node_validate($node, $form, &$form_state) {
  if ($node->type == 'digital_heritage') {
    $original_node = node_load($node->nid);

    // Do not allow adding, changing, or removing of Community Records in the DH node form. The field is there only to allow users to reorder the Community Records.
    $original_community_records = [];
    if (isset($original_node->field_community_record_children) && isset($original_node->field_community_record_children[LANGUAGE_NONE])) {
      foreach ($original_node->field_community_record_children[LANGUAGE_NONE] as $original_child) {
        $original_community_records[] = $original_child['target_id'];
      }
    }

    $new_community_records = [];
    if (isset($node->field_community_record_children)) {
      foreach ($node->field_community_record_children[LANGUAGE_NONE] as $new_child) {
        if (isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
          $new_community_records[] = $new_child['target_id'];
          if (!in_array($new_child['target_id'], $original_community_records)) {
            form_set_error('field_community_record_children', t('Do not add Community Records here. Use the "Add Community Record" button instead.'));
          }
        }
      }
    }

    foreach ($original_community_records as $original_child) {
      if (!in_array($original_child, $new_community_records)) {
        form_set_error('field_community_record_children', t('Do not remove Community Records here. Instead, edit the Community Record, then press "Delete". Note, only the creator of the Community Record can delete it.'));
      }
    }

    // Do not allow adding, changing, or removing of Book Pages in the DH node form. The field is there only to allow users to reorder the Book Pages.
    $original_book_pages = [];
    if (isset($original_node->field_book_children) && isset($original_node->field_book_children[LANGUAGE_NONE])) {
      foreach ($original_node->field_book_children[LANGUAGE_NONE] as $original_child) {
        $original_book_pages[] = $original_child['target_id'];
      }
    }

    $new_book_pages = [];
    if (isset($node->field_book_children)) {
      foreach ($node->field_book_children[LANGUAGE_NONE] as $new_child) {
        if (isset($new_child['target_id']) && is_numeric($new_child['target_id'])) {
          $new_book_pages[] = $new_child['target_id'];
          if (!in_array($new_child['target_id'], $original_book_pages)) {
            form_set_error('field_book_children', t('Do not add Book Pages here. Use the "Add a Book Page" button instead.'));
          }
        }
      }
    }

    foreach ($original_book_pages as $original_child) {
      if (!in_array($original_child, $new_book_pages)) {
        form_set_error('field_book_children', t('Do not remove Book Pages here. Instead, edit the Book Page, then press "Delete".'));
      }
    }

  }
}


/**
 * Implements hook_node_insert().
 */
function ma_digitalheritage_node_insert($node) {
  if ($node->type == 'digital_heritage') {

    $dh_emw = entity_metadata_wrapper('node', $node);

    // If this is a Book Child, reindex the parent
    $book_parent = $dh_emw->field_book_parent->value();
    if (!empty($book_parent) && count($book_parent)) {
      search_api_index_specific_items_delayed(search_api_index_load('default_node_index'), [$book_parent->nid]);
    }

    // Create redirects on Community Record nodes to their parent
    if (isset($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'])) {
      $redirect = new stdClass();
      redirect_object_prepare(
        $redirect,
        [
          'source' => 'node/' . $node->nid,
          'source_options' => [],
          'redirect' => 'node/' . $node->field_community_record_parent[LANGUAGE_NONE][0]['target_id'],
          'redirect_options' => [],
          'language' => LANGUAGE_NONE,
        ]
      );
      redirect_save($redirect);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function ma_digitalheritage_node_delete($node) {
  if ($node->type == 'digital_heritage') {
    $dh_emw = entity_metadata_wrapper('node', $node);

    // Delete the Community Records of a parent DH if the parent is deleted
    foreach ($dh_emw->field_community_record_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a Community Record is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

    // Delete the child pages of a book if the parent is deleted
    foreach ($dh_emw->field_book_children->value() as $child) {
      if (isset($child->nid)) {
        if ($child->nid <> $node->nid) { // In case a book page is a child of itself (which shouldn't happen but just in case to prevent infinite loop)
          node_delete($child->nid);
        }
      }
    }

  }
}

/**
 * Implements hook_search_api_index_items_alter().
 */
function ma_digitalheritage_search_api_index_items_alter(array &$items, SearchApiIndex $index) {
  /* foreach($items as $id => $item){

    // Exclude Community Record DH nodes from being indexed
    if (isset($item->field_community_record_parent[LANGUAGE_NONE])) {
     unset($items[$id]);
    }

    // Exclude DH Child pages from being indexed
    if (isset($item->field_book_parent[LANGUAGE_NONE])) {
      unset($items[$id]);
    }

  } */
}


/**
 * Implements hook_node_load().
 */
function ma_digitalheritage_node_load($nodes, $types) {

  // For Community Records, show the parent record's atoms
  if (in_array('digital_heritage', $types)) {
    foreach ($nodes as $node) {
      if (isset($node->field_community_record_parent[LANGUAGE_NONE])) {
        $parent_node = node_load($node->field_community_record_parent[LANGUAGE_NONE][0]['target_id']);
        if (isset($parent_node->field_media_asset[LANGUAGE_NONE])) {
          $node->field_media_asset = $parent_node->field_media_asset;
        }
      }
    }
  }
}

/**
 * Implements hook_page_alter().
 */
function ma_digitalheritage_page_alter(&$data) {

  // If there are Child Records for a DH node, show the parent and child records in quicktabs
  if (isset($data['content']['system_main']['nodes']) && !isset($data['content']['system_main']['term_heading']['term'])) {
    $dh_page_content = "";
    $array_keys = array_keys($data['content']['system_main']['nodes']);
    $node = $data['content']['system_main']['nodes'][array_shift($array_keys)]["#node"];
    if ($node && $node->type == 'digital_heritage') {

      // Custom build page content for DH nodes
      $nids = element_children($data['content']['system_main']['nodes']);
      $nid = $nids[0];

      // Book pages
      if ($node->field_book_children OR $node->field_book_parent) {
        // Future use of ma_digital_heritage_book_page_build_carousel is deprecated. Still use it in the case where
        // the old mukurtu_starter theme is still in use, or a sub-theme of mukurtu_starter.
        // Themes going forward should implement this in the template layer.
        global $theme;
        $theme_list = list_themes();
        if ($theme == 'mukurtu_starter' || (isset($theme_list[$theme]->base_themes) && isset($theme_list[$theme]->base_themes['mukurtu_starter']))) {
          drupal_add_js(drupal_get_path('module', 'ma_digitalheritage') . '/js/dh_multipage_carousel.js');
          $dh_page_content = ma_digital_heritage_book_page_build_carousel($node);
        }
      }

      // Community Records
      $parent_dh = entity_metadata_wrapper('node', $nid);
      if ($community_records = $parent_dh->field_community_record_children->value()) {

        $tab_settings = [
          'ajax' => 0,
          'default_tab' => 0,
          'title' => 'DH Tabs',
          'renderer' => 'quicktabs',
          'style' => 'Excel',
          'hide_empty_tabs' => 1,
        ];

        // Parent tab
        $parent_parent_community = node_load($node->field_community_ref[LANGUAGE_NONE][0]['nid']);
        $dh_tabs[] = [
          'type' => 'node',
          'nid' => $nid,
          'view_mode' => 'full',
          'title' => $parent_parent_community->title . ' Record',
          'hide_title' => 0,
          #'weight' => 0,
        ];

        $cr_tab_count = 1;
        $cr_tab_index = 0;
        $cr_redirect_source = !empty($_SESSION['mukurtu']['redirect_source']) ? $_SESSION['mukurtu']['redirect_source'] : -1;
        $cr_redirect_parent = !empty($_SESSION['mukurtu']['redirect_dest']) ? $_SESSION['mukurtu']['redirect_dest'] : -1;
        foreach ($community_records as $community_record) {

          global $user;
          if (mukurtu_protocol_field_node_access($community_record, 'view', $user) == 'allow') {

            // Tab title
            $community_record_parent_communities = [];
            foreach ($community_record->field_community_ref[LANGUAGE_NONE] as $community_record_parent_community) {
              $community_record_parent_community_node = node_load($community_record_parent_community['nid']);
              $community_record_parent_communities[] = $community_record_parent_community_node->title;
            }
            $community_record_tab_title = implode(' / ', $community_record_parent_communities) . ' Record';

            // Create the tab
            $dh_tabs[] = [
              'type' => 'node',
              'nid' => $community_record->nid,
              'view_mode' => 'full',
              'title' => $community_record_tab_title,
              'hide_title' => 0,
              #'weight' => 0,
            ];

            // If we are coming from a community record redirect, check if this is the correct CR.
            if ($community_record->nid == $cr_redirect_source) {
              // Store the tab index for the community record doing the redirect
              $cr_tab_index = $cr_tab_count;
            }
            $cr_tab_count++;
          }

          // User does not have view access to the Community Record. Create an empty tab (which does not render) to maintain tab index for direct linking to tabs
          else {
            $dh_tabs[] = [];
          }
        }

        // Only display quicktabs if there are multiple tabs the user can *view*.
        if ($cr_tab_count > 1) {
          // Set default tab in the case that we are coming from a community record redirect.
          if ($cr_redirect_parent == $parent_dh->getIdentifier() && $cr_tab_index > 0) {
            $tab_settings['default_tab'] = $cr_tab_index;

            // Clear the redirect info, if the page is refreshed,
            // we want to default back to the parent being default.
            unset($_SESSION['mukurtu']['redirect_source']);
            unset($_SESSION['mukurtu']['redirect_dest']);
          }

          // Add the rendered quicktabs to the built page content.
          $community_record_tabs = quicktabs_build_quicktabs("community-record", $tab_settings, $dh_tabs);
          foreach ($community_record_tabs['content']['content']['tabs']['tablinks'] as $key => $tab) {
            // Shorten title if necessary.  Long titles break the tabs.
            if (strlen($tab['#title']) > 25) {
              $comma_break_pos = strpos($tab['#title'], ',', 18);
              $colon_break_pos = strpos($tab['#title'], ':', 18);
              $word_break_pos = strpos($tab['#title'], ' ', 18);
              $break_pos = 25;

              if ($comma_break_pos > 0) {
                $break_pos = $comma_break_pos;
              }

              if ($colon_break_pos > 0 && $colon_break_pos < $break_pos) {
                $break_pos = $colon_break_pos;
              }

              if ($word_break_pos > 0 && $word_break_pos < $break_pos) {
                $break_pos = $word_break_pos;
              }

              $community_record_tabs['content']['content']['tabs']['tablinks'][$key]['#options']['attributes']['title'] = $tab['#title'];
              $community_record_tabs['content']['content']['tabs']['tablinks'][$key]['#title'] = substr($tab['#title'], 0, $break_pos) . '...';
            }
          }

          $dh_page_content .= drupal_render($community_record_tabs);
        }
        else {
          // There is only one record the user has view access for.
          // Render the single node normally, without quicktabs.
          $node_array = node_view($node, 'full');
          $dh_page_content .= drupal_render($node_array);
        }
      }

      // Node does not have community records. Render DH normally.
      else {
        $node_array = node_view($node, 'full');
        $dh_page_content .= drupal_render($node_array);
      }

      // Rewrite the output for DH nodes with our built DH page content
      $data['content']['system_main']['#markup'] = $dh_page_content;
    }
  }
}

function ma_digital_heritage_book_page_get_carousel_image($node) {
  if (isset($node->field_media_asset)) {
    $sid = $node->field_media_asset[LANGUAGE_NONE][0]['sid'];
    $atom = scald_atom_load($sid);
    if ($atom && !empty($atom->scald_thumbnail)) {
      return image_style_url('carousel_thumbnail', $atom->scald_thumbnail[LANGUAGE_NONE][0]['uri']);
    }
    else {
      switch ($atom->type) {
        case 'audio':
          return url(drupal_get_path('module', 'ma_digitalheritage') . '/images/default_audio_thumbnail_150.jpg');
        case 'file':
          return url(drupal_get_path('module', 'ma_digitalheritage') . '/images/default_file_thumbnail_150.jpg');
        case 'video':
          return url(drupal_get_path('module', 'ma_digitalheritage') . '/images/default_video_thumbnail_150.jpg');
        default:
          return url(drupal_get_path('module', 'ma_digitalheritage') . '/images/no_media_available_150.jpg');
      }
    }
  }
  return url(drupal_get_path('module', 'ma_digitalheritage') . '/images/no_media_available_150.jpg');
}

/**
 * Implements hook_file_download()
 */
function ma_digitalheritage_file_download($uri) {
  $info = image_get_info($uri);

  // Allow carousel thumbnails for multipage DH items to be cached locally for a week
  if (isset($info['mime_type']) && strpos($info['mime_type'], 'image/') === 0 && strpos($uri, 'carousel_thumbnail') > 0) {
    return [
      'Cache-Control' => 'max-age=604800, private',
      'Expires' => gmdate('D, d M Y H:i:s', time() + 604800) . ' GMT',
      'Last-Modified' => gmdate('D, d M Y H:i:s', time() - 604800) . ' GMT',
      'ETag' => strtr(md5($info['file_size']), 0, 10),
    ];
  }
}

/**
 * Implements hook_owlcarousel_settings_alter().
 *
 * @param array
 *   Settings array to apply.
 * @param string
 *   Settings group identifier.
 */
function ma_digitalheritage_owlcarousel_settings_alter(&$settings, $instance) {
  $parameters = drupal_get_query_parameters();
  if (isset($parameters['position']) && is_numeric($parameters['position']) && $parameters['position'] >= 0) {
    $settings['settings']['startPosition'] = $parameters['position'];
  }
  else {
    if (isset($_SESSION['multipage_dh_start_position']) && is_numeric($_SESSION['multipage_dh_start_position'])) {
      $settings['settings']['startPosition'] = $_SESSION['multipage_dh_start_position'];
    }
  }
}

// TODO: This whole one-off carousel needs to be rebuilt in our display formatter module
function ma_digital_heritage_book_page_build_carousel($node) {
  $active_page = 0;
  if (isset($node->field_book_children) && count($node->field_book_children) > 0) {
    // We are on the first page
    $parent_node = $node;
    $parent_emw = entity_metadata_wrapper('node', $node);
    $class = " class='selected' ";
    $combo_selected = "selected='selected'";
  }
  else {
    // We are on a child page
    $parent_node = node_load($node->field_book_parent[LANGUAGE_NONE][0]['target_id']);
    $parent_emw = entity_metadata_wrapper('node', $parent_node);
    $class = "";
    $combo_selected = "";
  }

  $children = $parent_emw->field_book_children->value();

  $pages = [];
  $combobox = "<div id='mulitpage-select'><form name='multipagecombo'><select class='form-control' id=\"urlSelect\" onchange=\"window.location = jQuery('#urlSelect option:selected').val();\">";

  $image = ma_digital_heritage_book_page_get_carousel_image($parent_node);
  $url = url(drupal_get_path_alias('node/' . $parent_node->nid));
  $combobox .= "<option value='$url' $combo_selected>" . $parent_node->title . " [Page 1]</option>";
  $pages[]['row'] = "<div$class><a href='$url'><img src=$image><div class='page-number'>Page 1</div></a></div>";
  $page_number = 2;
  foreach ($children as $page) {
    $image = ma_digital_heritage_book_page_get_carousel_image($page);
    $url = url(drupal_get_path_alias('node/' . $page->nid));
    $class = "";
    $combo_selected = "";
    if ($page->nid == $node->nid) {
      $active_page = $page_number - 1;
      $class = " class='selected' ";
      $combo_selected = "selected='selected'";
    }

    $combobox .= "<option value='$url' $combo_selected>" . $page->title . " [Page $page_number]</option>";
    $pages[]['row'] = "<div$class><a href='$url'><img src=$image><div class='page-number'>Page $page_number</div></a></div>";
    $page_number += 1;
  }
  $combobox .= "</select></form></div>";

  $_SESSION['multipage_dh_start_position'] = $active_page;
  $output = [
    '#theme' => 'owlcarousel',
    '#items' => $pages,
    '#settings' => [
      // The settings group to apply.
      'instance' => 'owlcarousel_settings_multipage',
      // Attributes are rendered via drupal_attributes on the wrapper element.
      'attributes' => [
        'id' => [
          'default' => drupal_html_id('multipage_carousel_' . $instance['field_id']),
        ],
        'class' => ['owl-carousel'],
      ],
    ],
  ];

  $rendered_output = drupal_render($output);

  // Quick and dirty fix for next/previous button styling after Owl Carousel update
  $rendered_output = str_replace('owl-theme', '', $rendered_output);

  unset($_SESSION['multipage_dh_start_position']);
  return $rendered_output . $combobox;
}

function ma_digital_heritage_book_page_navigation_buttons($node) {
  $output = "";

  $parent_emw = entity_metadata_wrapper('node', $node);
  $children = $parent_emw->field_book_children->value();
  if ($node->field_book_children) {
    $first = $left = $node;
    $right = $children[0];
  }

  // Child pages show arrows left, right, and up arrows
  elseif ($node->field_book_parent) {
    $child_emw = entity_metadata_wrapper('node', $node);
    $parent_node = $child_emw->field_book_parent->value();
    $first = $parent_node;
    $parent_emw = entity_metadata_wrapper('node', $parent_node);
    $children = $parent_emw->field_book_children->value();
    foreach ($children as $child_index => $child) {
      if ($child->nid == $node->nid) {
        if (isset ($children[$child_index - 1])) {
          $left = $children[$child_index - 1];
        }
        else {
          $left = $parent_node;
        }
        if (isset ($children[$child_index + 1])) {
          $right = $children[$child_index + 1];
        }
        else {
          $right = $node;
        }
        break;
      }
    }
  }

  // Render the navigation for all parent and child pages
  if (count($children)) {
    $last = end($children);
    $output .= '<div class = "dh-book-nav">';
    $output .= '<span class = "nav-button">' . l('<<', 'node/' . $first->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('<', 'node/' . $left->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('>', 'node/' . $right->nid) . '</span>';
    $output .= '<span class = "nav-button">' . l('>>', 'node/' . $last->nid) . '</span>';

    // Plus button to add a child page if user is the node owner
    global $user;
    if ($node->uid == $user->uid) {
      $output .= l('+', 'node/add/digital-heritage/book-page/' . $node->nid);
    }

    $output .= '</div>';
    return $output;
  }

}


function ma_digital_heritage_book_page_contents($node) {

  // Parent book pages show a table of contents
  $toc = '<ol><li>' . $node->title . '</li>';
  $parent_emw = entity_metadata_wrapper('node', $node);
  $children = $parent_emw->field_book_children->value();
  foreach ($children as $child) {
    $toc .= '<li>' . l($child->title, 'node/' . $child->nid) . '</li>';
  }
  $toc .= '</ol>';

  return '<div class = "dh-book-nav-toc">' . $toc . '</div>';
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ma_digitalheritage_form_node_delete_confirm_alter(&$form, &$form_state) {

  // Extra confirmation text when deleting a book parent
  if (count($form['#node']->field_book_children)) {
    $form['description']['#markup'] = "<p><b>This will delete ALL the pages in this book.</b></p>" . $form['description']['#markup'];
    drupal_set_title("Are you sure you want to delete the entire book for <i>" . $form['#node']->title . "</i>?", PASS_THROUGH);
  }

  // Extra confirmation text when deleting a community record parent
  if (count($form['#node']->field_community_record_children)) {
    $form['description']['#markup'] = "<p><b>This will delete all of its Community Records.</b></p>" . $form['description']['#markup'];
    drupal_set_title("Are you sure you want to delete <i>" . $form['#node']->title . "</i> and all of its Community Records?", PASS_THROUGH);
  }
}

/**
 * Implements hook_redirect_alter().
 */
function ma_digitalheritage_redirect_alter($redirect) {
  // Store most recent redirect per session.
  // We want to use that information to set the default tab for community records.
  $_SESSION['mukurtu']['redirect_source'] = str_replace('node/', '', $redirect->source);
  $_SESSION['mukurtu']['redirect_dest'] = str_replace('node/', '', $redirect->redirect);

  // Now that CRs show up in search results, we need to be able to click through to an
  // accessible CR that has an inaccessible parent.
  // First check if the user can get to the redirect location.
  // If they can, we don't need to do anything.
  if (!drupal_valid_path($redirect->redirect)) {
    // User cannot get to the redirect path.
    // Do they have access to the original path?
    if (drupal_valid_path($redirect->source)) {
      // Is this a community record?
      $node = menu_get_object('node', 1, $redirect->source);

      if ($node && !empty($node->field_community_record_parent[LANGUAGE_NONE])) {
        // It is a community record. Disable the redirect.
        // This will show only the single community record.
        // Long term we should show the others here.
        $redirect->redirect = FALSE;
      }
    }
  }
}

/**
 * Used in DS field community_record_title.
 */
function _ma_digitalheritage_ds_community_record_title($entity) {
  if (ma_core_is_community_record($entity)) {
    return l($entity->title, "node/$entity->nid");
  }
}
