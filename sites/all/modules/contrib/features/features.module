<?php

/**
 * @file
 * Main *.module file for the 'features' module.
 */

define('FEATURES_API', '2');

define('FEATURES_MODULE_ENABLED', 1);
define('FEATURES_MODULE_DISABLED', 0);
define('FEATURES_MODULE_MISSING', -1);
define('FEATURES_MODULE_CONFLICT', 2);

define('FEATURES_REBUILDABLE', -1);
define('FEATURES_DEFAULT', 0);
define('FEATURES_OVERRIDDEN', 1);
define('FEATURES_NEEDS_REVIEW', 2);
define('FEATURES_REBUILDING', 3);
define('FEATURES_CONFLICT', 4);
define('FEATURES_DISABLED', 5);
define('FEATURES_CHECKING', 6);
define('FEATURES_ALTER_TYPE_NORMAL', 'normal');
define('FEATURES_ALTER_TYPE_INLINE', 'inline');
define('FEATURES_ALTER_TYPE_NONE', 'none');

/**
 * Duration of rebuild semaphore: 10 minutes.
 */
define('FEATURES_SEMAPHORE_TIMEOUT', 10 * 60);

/**
 * Components with this 'default_file' flag will have exports written to the
 * common defaults file 'MODULENAME.features.inc'. This is the default
 * behavior.
 */
define('FEATURES_DEFAULTS_INCLUDED_COMMON', 0);

/**
 * Components with this 'default_file' flag will have exports written to a
 * defaults based on the component name like 'MODULENAME.features.COMPONENT-NAME.inc'.
 * Any callers to this component's defaults hook must call
 * features_include_defaults('component') in order to include this file.
 */
define('FEATURES_DEFAULTS_INCLUDED', 1);

/**
 * Components with this 'default_file' flag must specify a filename for their
 * exports. Additionally a stub will NOT be written to 'MODULENAME.features.inc'
 * allowing the file to be included directly by the implementing module.
 */
define('FEATURES_DEFAULTS_CUSTOM', 2);

/**
 * Components with this 'duplicates' flag may not have multiple features provide the
 * same component key in their info files. This is the default behavior.
 */
define('FEATURES_DUPLICATES_CONFLICT', 0);

/**
 * Components with this 'duplicates' flag are allowed to have multiple features
 * provide the same component key in their info files.
 */
define('FEATURES_DUPLICATES_ALLOWED', 1);

/**
 * The default destination path for features exported via the UI.
 */
define('FEATURES_DEFAULT_EXPORT_PATH', 'sites/all/modules');

/**
 * Implements hook_menu().
 */
function features_menu() {
  $items = array();
  $items['admin/structure/features'] = array(
    'title' => 'Features',
    'description' => 'Manage features.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_admin_form() */
    'page arguments' => array('features_admin_form'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/cleanup'] = array(
    'title' => 'Cleanup',
    'description' => 'Clear cache after enabling/disabling a feature.',
    /* @see \features_cleanup() */
    'page callback' => 'features_cleanup',
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
    'weight' => 1,
  );
  $items['admin/structure/features/manage'] = array(
    'title' => 'Manage',
    'description' => 'Enable and disable features.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_admin_form() */
    'page arguments' => array('features_admin_form'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/create'] = array(
    'title' => 'Create feature',
    'description' => 'Create a new feature.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_export_form() */
    'page arguments' => array('features_export_form'),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 10,
  );
  $items['admin/structure/features/settings'] = array(
    'title' => 'Settings',
    'description' => 'Adjust settings for using features module.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_settings_form() */
    'page arguments' => array('features_settings_form'),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 11,
  );

  /* @see \feature_load() - the wildcard loader callback. */
  $items['admin/structure/features/%feature'] = array(
    /* @see \features_get_feature_title() */
    'title callback' => 'features_get_feature_title',
    'title arguments' => array(3),
    'description' => 'Display components of a feature.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_admin_components() */
    'page arguments' => array('features_admin_components', 3),
    'load arguments' => array(TRUE),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/%feature/view'] = array(
    'title' => 'View',
    'description' => 'Display components of a feature.',
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/features/%feature/recreate'] = array(
    'title' => 'Recreate',
    'description' => 'Recreate an existing feature.',
    /* @see \drupal_get_form() */
    'page callback' => 'drupal_get_form',
    /* @see \features_export_form() */
    'page arguments' => array('features_export_form', 3),
    'load arguments' => array(TRUE),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_LOCAL_TASK,
    'file' => "features.admin.inc",
    'weight' => 11,
  );
  if (module_exists('diff')) {
    $items['admin/structure/features/%feature/diff'] = array(
      'title' => 'Review overrides',
      'description' => 'Compare default and current feature.',
      /* @see \features_feature_diff() */
      'page callback' => 'features_feature_diff',
      'page arguments' => array(3, 5),
      'load arguments' => array(TRUE),
      /* @see \features_access_override_actions() */
      'access callback' => 'features_access_override_actions',
      'access arguments' => array(3),
      'type' => MENU_LOCAL_TASK,
      'file' => 'features.admin.inc',
    );
  }

  $items['admin/structure/features/%feature/lock'] = array(
    'title' => 'Lock',
    'description' => 'Lock a feature or components.',
    /* @see \features_admin_lock() */
    'page callback' => 'features_admin_lock',
    'page arguments' => array(3, 5, 6),
    'load arguments' => array(TRUE),
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['admin/structure/features/%feature/status'] = array(
    'title' => 'Status',
    'description' => 'Javascript status call back.',
    /* @see \features_feature_status() */
    'page callback' => 'features_feature_status',
    'page arguments' => array(3),
    'load arguments' => array(TRUE),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['features/autocomplete/packages'] = array(
    /* @see \features_autocomplete_packages() */
    'page callback' => 'features_autocomplete_packages',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  $items['features/ajaxcallback/%'] = array(
    'title' => 'AJAX callback',
    'description' => 'Return components of a feature.',
    /* @see \features_export_components_json() */
    'page callback' => 'features_export_components_json',
    'page arguments' => array(2),
    /* @see \user_access() */
    'access callback' => 'user_access',
    'access arguments' => array('administer features'),
    'type' => MENU_CALLBACK,
    'file' => 'features.admin.inc',
  );
  foreach ($items as $path => $item) {
    if (!isset($item['access callback'])) {
      /* @see \user_access() */
      $items[$path]['access callback'] = 'user_access';
      $items[$path]['access arguments'] = array('manage features');
    }
  }
  return $items;
}

/**
 * Implements hook_theme().
 */
function features_theme() {
  $base = array(
    'path' => drupal_get_path('module', 'features') . '/theme',
    'file' => 'theme.inc',
  );

  $items = array();
  /* @see \theme_features_module_status() */
  $items['features_module_status'] = array(
    'variables' => array('module' => NULL, 'status' => NULL),
  ) + $base;

  /* @see \theme_features_components() */
  $items['features_components'] = array(
    'variables' => array('info' => NULL, 'sources' => NULL),
  ) + $base;

  /* @see \theme_features_component_key() */
  $items['features_component_key'] = $base;
  /* @see \theme_features_component_list() */
  $items['features_component_list'] = array(
    'variables' => array('components' => array(), 'source' => array(), 'conflicts' => array()),
  ) + $base;

  /* @see \theme_features_storage_link() */
  $items['features_storage_link'] = array(
    'variables' => array('storage' => NULL, 'text' => NULL, 'path' => NULL, 'options' => array()),
  ) + $base;

  /* @see \theme_features_lock_link() */
  $items['features_lock_link'] = array(
    'variables' => array('feature' => NULL, 'component' => NULL, 'locked' => FALSE),
  ) + $base;

  /* @see \theme_features_form_components() */
  $items['features_form_components'] =
  /* @see \theme_features_form_export() */
  $items['features_form_export'] =
  /* @see \theme_features_form_package() */
  $items['features_form_package'] = array(
    'render element' => 'form',
  ) + $base;

  /* @see \theme_features_form_buttons() */
  $items['features_form_buttons'] = array(
    'render element' => 'element',
  ) + $base;

  // Theme hook for 'features_admin_components' form.
  /* @see \template_preprocess_features_admin_components() */
  /* @see \features_admin_components() */
  $items['features_admin_components'] = array(
    'render element' => 'form',
    'template' => 'features-admin-components',
  ) + $base;

  return $items;
}

/**
 * Implements hook_flush_caches().
 */
function features_flush_caches() {
  if (($modules_changed = variable_get('features_modules_changed', FALSE)) || variable_get('features_rebuild_on_flush', TRUE)) {
    if ($modules_changed) {
      variable_set('features_modules_changed', FALSE);
    }
    features_rebuild();
    // Don't flush the modules cache during installation, for performance
    // reasons.
    if (variable_get('install_task') == 'done') {
      features_get_modules(NULL, TRUE);
    }
  }

  if (db_table_exists('cache_features')) {
    return array('cache_features');
  }
  return array();
}

/**
 * Implements hook_form().
 */
function features_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Implements hook_permission().
 */
function features_permission() {
  return array(
    'administer features' => array(
      'title' => t('Administer features'),
      'description' => t('Perform administration tasks on features.'),
      'restrict access' => TRUE,
    ),
    'manage features' => array(
      'title' => t('Manage features'),
      'description' => t('View, enable and disable features.'),
      'restrict access' => TRUE,
    ),
    'generate features' => array(
      'title' => t('Generate features'),
      'description' => t('Allow feature exports to be generated and written directly to site.'),
      'restrict access' => TRUE,
    ),
    'rename features' => array(
      'title' => t('Edit feature machine name'),
      'description' => t('Allows editing machine name of a disabled feature'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_help().
 */
function features_help($path, $arg) {
  switch ($path) {
    case 'admin/help#features':
      // Use dirname(__FILE__) instead of __DIR__ for PHP < 5.3 (ouch).
      $path_to_readme = dirname(__FILE__) . '/README.txt';
      if (!is_readable($path_to_readme) || !is_file($path_to_readme)) {
        // The README.txt is not readable, or does not exist.
        // This can happen in sites that remove or hide README.txt files on
        // deployment. See #2473935.
        return NULL;
      }
      $output = file_get_contents($path_to_readme);
      return module_exists('markdown') ? filter_xss_admin(module_invoke('markdown', 'filter', 'process', 0, -1, $output)) : '<pre>' . check_plain($output) . '</pre>';

    case 'admin/build/features':
      return '<p>' . t('A "Feature" is a certain type of Drupal module which contains a package of configuration that, when enabled, provides a new set of functionality for your Drupal site. Enable features by selecting the checkboxes below and clicking the Save configuration button. If the configuration of the feature has been changed its "State" will be either "overridden" or "needs review", otherwise it will be "default", indicating that the configuration has not been changed. Click on the state to see more details about the feature and its components.') . '</p>';
  }
}

/**
 * Implements hook_modules_disabled().
 */
function features_modules_disabled($modules) {
  // Go through all modules and gather features that can be disabled.
  $items = array();
  foreach ($modules as $module) {
    if ($feature = features_load_feature($module)) {
      $items[$module] = array_keys($feature->info['features']);
    }
  }

  if (!empty($items)) {
    _features_restore('disable', $items);
    // Rebuild the list of features includes.
    features_include(TRUE);
  }
}

/**
 * Implements hook_modules_enabled().
 */
function features_modules_enabled($modules) {
  // Allow distributions to disable this behavior and rebuild the features
  // manually inside a batch.
  if (!variable_get('features_rebuild_on_module_install', TRUE)) {
    return;
  }

  // Mark modules as being changed for test in features_flush_caches.
  variable_set('features_modules_changed', TRUE);

  // Go through all modules and gather features that can be enabled.
  $items = array();
  foreach ($modules as $module) {
    if ($feature = features_load_feature($module)) {
      $items[$module] = array_keys($feature->info['features']);
    }
  }

  if (!empty($items)) {
    // Need to include any new files.
    // @todo Redo function so can take in list of modules to include.
    features_include_defaults(NULL, TRUE);
    _features_restore('enable', $items);
    // Rebuild the list of features includes.
    features_include(TRUE);
    // Reorders components to match hook order and removes non-existant.
    $all_components = array_keys(features_get_components());
    foreach ($items as $module => $components) {
      $items[$module] = array_intersect($all_components, $components);
    }
    _features_restore('rebuild', $items);
  }
}

/**
 * Includes PHP files where features components are defined.
 *
 * The function does the following:
 * - Include the files in 'includes/features.*.inc', where features defines
 *   components on behalf of other modules.
 * - Dynamically declare the functions for features components based on ctools.
 * - Include files that contain component hooks, as specified in the 'file'
 *   property of each component.
 *
 * @param bool $reset
 *   (optional) If TRUE, the operation will run again even if it has run before
 *   in the same request. This is useful e.g. if additional modules were enabled
 *   since then.
 */
function features_include($reset = FALSE) {
  static $once;
  if (!isset($once) || $reset) {
    $once = TRUE;

    // Features provides integration on behalf of these modules.
    // The features include provides handling for the feature dependencies.
    // Note that ctools is placed last because it implements hooks "dynamically"
    // for other modules.
    $modules = array('features', 'block', 'contact', 'context', 'field', 'filter', 'image', 'locale', 'menu', 'node', 'taxonomy', 'user', 'views', 'ctools');

    foreach (array_filter($modules, 'module_exists') as $module) {
      module_load_include('inc', 'features', "includes/features.$module");
    }

    if (module_exists('ctools')) {
      // Finally, add ctools eval'd implementations.
      ctools_features_declare_functions($reset);
    }

    // Clear static cache, since we've now included new implementers.
    foreach (features_get_components(NULL, 'file', $reset) as $file) {
      if (is_file(DRUPAL_ROOT . '/' . $file)) {
        require_once DRUPAL_ROOT . '/' . $file;
      }
    }
  }
}

/**
 * Includes PHP files that contain (generated) default hook implementations.
 *
 * The file to include for each feature module for a given component can be
 * specified in the component info in hook_features_api().
 *
 * @param string[]|string|null $components
 *   (optional) A list of component names, or one component name, or NULL.
 *   If provided, only the files for the specified components are included.
 * @param bool $reset
 *   (optional) If TRUE, the operation will run again even if it has already run
 *   during the same request. This is useful e.g. when new modules were enabled.
 */
function features_include_defaults($components = NULL, $reset = FALSE) {
  static $include_components;

  // Build an array of components that require inclusion:
  // Views, CTools components and those using FEATURES_DEFAULTS_INCLUDED.
  if (!isset($include_components) || $reset) {
    $include_components = features_get_components();
    foreach ($include_components as $component => $info) {
      if (!isset($info['api']) && (!isset($info['default_file']) || $info['default_file'] !== FEATURES_DEFAULTS_INCLUDED)) {
        unset($include_components[$component]);
      }
    }
  }

  // If components are specified, only include for the specified components.
  if (isset($components)) {
    $components = is_array($components) ? $components : array($components);
  }
  // Use all include components if none are explicitly specified.
  else {
    $components = array_keys($include_components);
  }
  foreach ($components as $component) {
    if (isset($include_components[$component])) {
      $info = $include_components[$component];
      // Inclusion of ctools components.
      if (isset($info['api'], $info['module'], $info['current_version'])) {
        ctools_include('plugins');
        ctools_plugin_api_include($info['module'], $info['api'], $info['current_version'], $info['current_version']);
      }
      // Inclusion of defaults for components using FEATURES_DEFAULTS_INCLUDED.
      else {
        $features = isset($features) ? $features : features_get_features(NULL, $reset);
        foreach ($features as $feature) {
          $filename = isset($info['default_file']) && $info['default_file'] == FEATURES_DEFAULTS_CUSTOM ? $info['default_filename'] : "features.{$component}";
          if (module_exists($feature->name) && isset($feature->info['features'][$component])) {
            module_load_include('inc', $feature->name, "{$feature->name}.$filename");
          }
        }
      }
    }
  }
}

/**
 * Menu wildcard loader for '%feature'.
 *
 * @param string $name
 *   Path fragment.
 * @param bool $reset
 *   (optional) If TRUE, the cache will be cleared before fetching.
 *
 * @return \stdClass|false
 *   Object with module info, or FALSE if not found or not a feature.
 */
function feature_load($name, $reset = FALSE) {
  return features_load_feature($name, $reset);
}

/**
 * Gets an object with information about a feature module.
 *
 * @param string $name
 *   Name of a (feature) module.
 * @param bool $reset
 *   (optional) If TRUE, the cache will be cleared before fetching.
 *
 * @return \stdClass|false
 *   Object with module info, or FALSE if not found or not a feature.
 */
function features_load_feature($name, $reset = FALSE) {
  // Use an alternative code path during installation, for better performance.
  if (variable_get('install_task') != 'done') {
    static $features;

    if (!isset($features[$name])) {
      // Set defaults for module info.
      $defaults = array(
        'dependencies' => array(),
        'description' => '',
        'package' => 'Other',
        'version' => NULL,
        'php' => DRUPAL_MINIMUM_PHP,
        'files' => array(),
        'bootstrap' => 0,
      );
      $info = drupal_parse_info_file(drupal_get_path('module', $name) . '/' . $name . '.info');

      $features[$name] = FALSE;
      if (!empty($info['features']) && empty($info['hidden'])) {
        // Build a fake file object with the data needed during installation.
        $features[$name] = new stdClass();
        $features[$name]->name = $name;
        $features[$name]->filename = drupal_get_path('module', $name) . '/' . $name . '.module';
        $features[$name]->type = 'module';
        $features[$name]->status = module_exists($name);
        $features[$name]->info = $info + $defaults;
      }
    }

    return $features[$name];
  }
  else {
    return features_get_features($name, $reset);
  }
}

/**
 * Return a module 'object' including .info information.
 *
 * @param string|null $name
 *   (optional) The name of the module to retrieve information for. If omitted,
 *   an array of all available modules will be returned.
 * @param bool $reset
 *   (optional) If TRUE, the cache will be reset before fetching.
 *
 * @return \stdClass[]|\stdClass|false
 *   If $name is NULL: $[$module] = $module_info_object
 *   If $name is not NULL: A specific module info object.
 *   If no matching module is found, FALSE is returned.
 */
function features_get_modules($name = NULL, $reset = FALSE) {
  return features_get_info('module', $name, $reset);
}

/**
 * Gets component types declared with hook_features_api().
 *
 * @param string $component
 *   (optional) A specific type of component that supports features.
 *   E.g. "field_instance".
 * @param string $key
 *   (optional) The name of a property to retrieve for each component type.
 *   E.g. "name", "default_hook" or "base".
 * @param bool $reset
 *   (optional) If TRUE, the components cache will be cleared.
 *
 * @return mixed|mixed[]|array|array[]|null
 *   Return value depending on parameters:
 *   - If both $component and $key are provided:
 *     A specific value from the info of the specified component.
 *   - If only $key is provided:
 *     List with the same value from each component.
 *   - If only $component is provided:
 *     Info array of the specified component.
 *     If the component is not found, a notice is triggered, and NULL is returned.
 *   - If neither $component nor $key are provided:
 *     List of component info arrays, keyed by component.
 *
 * @see \hook_features_api()
 */
function features_get_components($component = NULL, $key = NULL, $reset = FALSE) {
  features_include();
  $components = &drupal_static(__FUNCTION__);
  $component_by_key = &drupal_static(__FUNCTION__ . '_by_key');

  if ($reset || !isset($components) || !isset($component_by_key)) {
    $components = $component_by_key = array();
    if (!$reset && ($cache = cache_get('features_api', 'cache_features'))) {
      $components = $cache->data;
    }
    else {
      $components = module_invoke_all('features_api');
      drupal_alter('features_api', $components);
      cache_set('features_api', $components, 'cache_features');
    }

    foreach ($components as $component_type => $component_information) {
      foreach ($component_information as $component_key => $component_value) {
        $component_by_key[$component_key][$component_type] = $component_value;
      }
    }
  }

  if ($key && $component) {
    return !empty($components[$component][$key]) ? $components[$component][$key] : NULL;
  }
  elseif ($key) {
    return !empty($component_by_key[$key]) ? $component_by_key[$key] : array();
  }
  elseif ($component) {
    return $components[$component];
  }
  return $components;
}

/**
 * Returns components that are offered as an option on feature creation.
 *
 * @return array[]
 *   Components from hook_features_api() where 'features_source' is TRUE.
 *   Format: $[$component] = $component_info
 */
function features_get_feature_components() {
  return array_intersect_key(features_get_components(), array_filter(features_get_components(NULL, 'feature_source')));
}

/**
 * Invoke a component callback.
 *
 * @param string $component
 *   Component name, e.g. 'field_instance'.
 * @param string $callback
 *   Component hook name, e.g. 'features_revert'.
 *
 * @return mixed|void
 *   The return value from the component hook callback.
 *   If the callback does not exist, NULL ("void") is returned.
 *
 * @todo Explicitly return NULL if hook not found, replace the 'void' doc.
 */
function features_invoke($component, $callback) {
  $args = func_get_args();
  unset($args[0], $args[1]);
  // Append the component name to the arguments.
  $args[] = $component;
  if ($function = features_hook($component, $callback)) {
    return call_user_func_array($function, $args);
  }
}

/**
 * Checks whether a component implements the given hook.
 *
 * @param string $component
 *   A component name, e.g. 'field_instance'.
 * @param string $hook
 *   A component hook name, e.g. 'features_revert'.
 * @param bool $reset
 *   (obsolete) The parameter has no effect.
 *
 * @return string|false
 *   The function implementing the hook, or FALSE.
 *   E.g. 'field_instance_features_revert'.
 */
function features_hook($component, $hook, $reset = FALSE) {
  // Determine the function callback base.
  $base = features_get_components($component, 'base');
  $base = isset($base) ? $base : $component;
  return function_exists($base . '_' . $hook) ? $base . '_' . $hook : FALSE;
}

/**
 * Enables an array of (feature) modules and their dependencies.
 *
 * Modules that are already enabled and installed are ignored.
 * Consider this a helper or extension to module_enable().
 *
 * @param string[] $modules
 *   An array of module names or dependency strings.
 *
 * @see \module_enable()
 */
function features_install_modules($modules) {
  variable_set('features_modules_changed', TRUE);

  module_load_include('inc', 'features', 'features.export');
  $files = system_rebuild_module_data();

  // Build maximal list of dependencies.
  $install = array();
  foreach ($modules as $name) {
    // Parse the dependency string into the module name and version information.
    $parsed_name = drupal_parse_dependency($name);
    $name = $parsed_name['name'];
    if ($file = $files[$name]) {
      $install[] = $name;
      if (!empty($file->info['dependencies'])) {
        $install = array_merge($install, _features_export_maximize_dependencies($file->info['dependencies']));
      }
    }
  }

  // Filter out enabled modules.
  $enabled = array_filter($install, 'module_exists');
  $install = array_diff($install, $enabled);

  if (!empty($install)) {
    // Make sure the install API is available.
    $install = array_unique($install);
    include_once DRUPAL_ROOT . '/' . './includes/install.inc';
    module_enable($install);
  }
}

/**
 * Gets a list of module info objects that are features.
 *
 * @param string|null $name
 *   (optional) Name of a feature module.
 * @param bool $reset
 *   (optional) If TRUE, the cache will be cleared before fetching.
 *
 * @return \stdClass[]|\stdClass|false
 *   If $name is NULL: $[$module] = $module_info_object
 *   If $name is not NULL: A specific module info object.
 *   If no matching module is found, FALSE is returned.
 */
function features_get_features($name = NULL, $reset = FALSE) {
  return features_get_info('feature', $name, $reset);
}

/**
 * Retrieves module info from the system table.
 *
 * @param string $type
 *   (optional) One of 'module' or 'feature'.
 *   If 'module', all modules are returned.
 *   If 'feature', only those modules are returned that act as features.
 * @param string|null $name
 *   (optional) Name of a (feature or not) module.
 *   If the module is not a feature, and $type is 'feature', FALSE will be
 *   returned instead.
 * @param bool $reset
 *   (optional) If TRUE, the cache will be cleared before fetching.
 *
 * @return \stdClass[]|\stdClass|false
 *   If $name is NULL or empty:
 *     List of modules according to $type.
 *     Format: $[$module] = $module_info_object
 *   If $name is not NULL or empty:
 *     Module info object, if it matches $type.
 *     FALSE, if the module does not exist, or if $type is 'feature' and the
 *     module is not a feature.
 *   If $type is something other than 'module' or 'feature':
 *     FALSE, no matter the other parameters.
 *
 * @see system_rebuild_module_data()
 */
function features_get_info($type = 'module', $name = NULL, $reset = FALSE) {
  static $cache;
  if (!isset($cache)) {
    $cache = cache_get('features_module_info', 'cache_features');
  }
  if (empty($cache) || $reset) {
    $data = array(
      'feature' => array(),
      'module' => array(),
    );
    $ignored = variable_get('features_ignored_orphans', array());
    $files = system_rebuild_module_data();

    foreach ($files as $row) {
      // Remove modification timestamp, added in Drupal 7.33.
      if (isset($row->info['mtime'])) {
        unset($row->info['mtime']);
      }
      // Avoid false-reported feature overrides for php = 5.2.4 line in .info
      // file.
      if (isset($row->info['php'])) {
        unset($row->info['php']);
      }
      // If module is no longer enabled, remove it from the ignored orphans
      // list.
      if (in_array($row->name, $ignored, TRUE) && !$row->status) {
        $key = array_search($row->name, $ignored, TRUE);
        unset($ignored[$key]);
      }

      if (!empty($row->info['features'])) {
        // Fix css/js paths.
        if (!empty($row->info['stylesheets'])) {
          foreach ($row->info['stylesheets'] as $media => $css) {
            $row->info['stylesheets'][$media] = array_keys($css);
          }
        }
        if (!empty($row->info['scripts'])) {
          $row->info['scripts'] = array_keys($row->info['scripts']);
        }
        // Rework the features array, to change the vocabulary permission
        // features.
        foreach ($row->info['features'] as $component => $features) {
          if ($component == 'user_permission') {
            foreach ($features as $key => $feature) {
              // Export vocabulary permissions using the machine name, instead
              // of vocabulary id.
              _user_features_change_term_permission($feature);
              $row->info['features'][$component][$key] = $feature;
            }
          }
        }
        $data['feature'][$row->name] = $row;
        $data['feature'][$row->name]->components = array_keys($row->info['features']);
        if (!empty($row->info['dependencies'])) {
          $data['feature'][$row->name]->components[] = 'dependencies';
        }
      }
      $data['module'][$row->name] = $row;
    }

    // Sort features according to dependencies.
    // @see install_profile_modules()
    $required = array();
    $non_required = array();

    $modules = array_keys($data['feature']);
    foreach ($modules as $module) {
      if ($files[$module]->requires) {
        $modules = array_merge($modules, array_keys($files[$module]->requires));
      }
    }
    $modules = array_unique($modules);
    foreach ($modules as $module) {
      if (!empty($files[$module]->info['features'])) {
        if (!empty($files[$module]->info['required'])) {
          $required[$module] = $files[$module]->sort;
        }
        else {
          $non_required[$module] = $files[$module]->sort;
        }
      }
    }
    arsort($required);
    arsort($non_required);

    $sorted = array();
    foreach ($required + $non_required as $module => $weight) {
      $sorted[$module] = $data['feature'][$module];
    }
    $data['feature'] = $sorted;

    variable_set('features_ignored_orphans', $ignored);
    cache_set('features_module_info', $data, 'cache_features');
    $cache = new stdClass();
    $cache->data = $data;
  }
  if (!empty($name)) {
    return !empty($cache->data[$type][$name]) ? clone $cache->data[$type][$name] : FALSE;
  }
  return !empty($cache->data[$type]) ? $cache->data[$type] : FALSE;
}

/**
 * Generate an array of feature dependencies that have been orphaned.
 */
function features_get_orphans($reset = FALSE) {
  static $orphans;
  if (!isset($orphans) || $reset) {
    module_load_include('inc', 'features', 'features.export');
    $orphans = array();

    // Build a list of all dependencies for enabled and disabled features.
    $dependencies = array('enabled' => array(), 'disabled' => array());
    $features = features_get_features();
    foreach ($features as $feature) {
      $key = module_exists($feature->name) ? 'enabled' : 'disabled';
      if (!empty($feature->info['dependencies'])) {
        $dependencies[$key] = array_merge($dependencies[$key], _features_export_maximize_dependencies($feature->info['dependencies']));
      }
    }
    $dependencies['enabled'] = array_unique($dependencies['enabled']);
    $dependencies['disabled'] = array_unique($dependencies['disabled']);

    // Find the list of orphaned modules.
    $orphaned = array_diff($dependencies['disabled'], $dependencies['enabled']);
    $orphaned = array_intersect($orphaned, module_list(FALSE, FALSE));
    $orphaned = array_diff($orphaned, drupal_required_modules());
    $orphaned = array_diff($orphaned, array('features'));

    // Build final list of modules that can be disabled.
    $modules = features_get_modules(NULL, TRUE);
    $enabled = module_list();
    _module_build_dependencies($modules);

    foreach ($orphaned as $module) {
      if (!empty($modules[$module]->required_by)) {
        foreach ($modules[$module]->required_by as $module_name => $dependency) {
          $modules[$module]->required_by[$module_name] = $dependency['name'];
        }
        // Determine whether any dependents are actually enabled.
        $dependents = array_intersect($modules[$module]->required_by, $enabled);
        if (empty($dependents)) {
          $info = features_get_modules($module);
          $orphans[$module] = $info;
        }
      }
    }
  }
  return $orphans;
}

/**
 * Detects potential conflicts between features that provide the same items.
 *
 * @param bool $reset
 *   If TRUE, relevant caches will be reset.
 *
 * @return string[][][][]
 *   Format: $[$module_A][$module_B][$component][] = $name
 *   E.g. $['myfeature']['otherfeature']['node'][] = 'article'.
 *   Nested array/map of (feature) modules that have conflicting features.
 */
function features_get_conflicts($reset = FALSE) {
  $conflicts = array();
  $component_info = features_get_components();
  $map = features_get_component_map(NULL, $reset);

  foreach ($map as $type => $components) {
    // Only check conflicts for components we know about.
    if (isset($component_info[$type])) {
      foreach ($components as $component => $modules) {
        if (isset($component_info[$type]['duplicates']) && $component_info[$type]['duplicates'] == FEATURES_DUPLICATES_ALLOWED) {
          continue;
        }
        elseif (count($modules) > 1) {
          foreach ($modules as $module) {
            if (!isset($conflicts[$module])) {
              $conflicts[$module] = array();
            }
            foreach ($modules as $m) {
              if ($m != $module) {
                $conflicts[$module][$m][$type][] = $component;
              }
            }
          }
        }
      }
    }
  }

  return $conflicts;
}

/**
 * Provide a component to feature map.
 *
 * @param string|null $key
 *   (optional) Component type to filter by.
 * @param bool $reset
 *   (optional) If TRUE, relevant caches are reset.
 *
 * @return string[][][]|string[][]
 *   Format:
 *   - If $key is NULL:
 *     $[$component][$name][] = $module
 *   - If $key is not NULL:
 *     $[$name][] = $module
 */
function features_get_component_map($key = NULL, $reset = FALSE) {
  static $map;
  if (!isset($map) || $reset) {
    $map = array();
    $features = features_get_features(NULL, $reset);
    foreach ($features as $feature) {
      foreach ($feature->info['features'] as $type => $components) {
        if (!isset($map[$type])) {
          $map[$type] = array();
        }
        foreach ($components as $component) {
          $map[$type][$component][] = $feature->name;
        }
      }
    }
  }
  if (isset($key)) {
    return isset($map[$key]) ? $map[$key] : array();
  }
  return $map;
}

/**
 * Checks whether a module is enabled, disabled or missing.
 *
 * @param string $module
 *   A module name.
 *
 * @return int
 *   One of the constants mentioned below, depending on the module status.
 *
 * @see FEATURES_MODULE_ENABLED
 * @see FEATURES_MODULE_DISABLED
 * @see FEATURES_MODULE_MISSING
 */
function features_get_module_status($module) {
  if (module_exists($module)) {
    return FEATURES_MODULE_ENABLED;
  }
  elseif (features_get_modules($module)) {
    return FEATURES_MODULE_DISABLED;
  }
  else {
    return FEATURES_MODULE_MISSING;
  }
}

/**
 * Menu title callback.
 *
 * @param \stdClass $feature
 *   Feature module object.
 *
 * @return string
 *   The human name of the module, as specified in the *.info file.
 */
function features_get_feature_title($feature) {
  return $feature->info['name'];
}

/**
 * Menu access callback for 'admin/structure/features/%feature/diff'.
 *
 * Checks whether a user should be able to access override actions for a given
 * feature.
 *
 * @param \stdClass $feature
 *   Feature module object.
 *
 * @return bool
 *   TRUE to give access, FALSE to deny access.
 */
function features_access_override_actions($feature) {
  if (user_access('administer features')) {
    static $access = array();
    if (!isset($access[$feature->name])) {
      // Set a value first. We may get called again from within
      // features_detect_overrides().
      $access[$feature->name] = FALSE;

      features_include();
      module_load_include('inc', 'features', 'features.export');
      $access[$feature->name] = in_array(features_get_storage($feature->name), array(FEATURES_DEFAULT, FEATURES_OVERRIDDEN, FEATURES_NEEDS_REVIEW));
    }
    return $access[$feature->name];
  }
  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter() for 'system_modules' form().
 */
function features_form_system_modules_alter(&$form) {
  if (variable_get('features_rebuild_modules_page', FALSE)) {
    features_rebuild();
  }
}

/**
 * Restore the specified modules to the default state.
 *
 * @param string $op
 *   One of 'revert', 'rebuild', 'disable', 'enable'.
 * @param string[][] $items
 *   Modules and their components to be processed according to $op.
 *   If empty, all applicable feature modules will be processed.
 *   Format: $[$module_name][] = $component
 *   E.g. $['myfeature'][] = 'field_instance'.
 */
function _features_restore($op, $items = array()) {
  $lockable = FALSE;
  // Set this variable in $conf if having timeout issues during install/rebuild.
  if (variable_get('features_restore_time_limit_' . $op, FALSE) !== FALSE) {
    drupal_set_time_limit(variable_get('features_restore_time_limit_' . $op, FALSE));
  }

  module_load_include('inc', 'features', 'features.export');
  features_include();

  switch ($op) {
    case 'revert':
      $restore_states = array(FEATURES_OVERRIDDEN, FEATURES_REBUILDABLE, FEATURES_NEEDS_REVIEW);
      /* @see \hook_pre_features_revert() - module hook. */
      /* @see \hook_features_revert() - component hook. */
      /* @see \hook_post_features_revert() - module hook. */
      $restore_hook = 'features_revert';
      $log_action = 'Revert';
      $lockable = TRUE;
      break;

    case 'rebuild':
      $restore_states = array(FEATURES_REBUILDABLE);
      /* @see \hook_pre_features_rebuild() - module hook. */
      /* @see \hook_features_rebuild() - component hook. */
      /* @see \hook_post_features_rebuild() - module hook. */
      $restore_hook = 'features_rebuild';
      $log_action = 'Rebuild';
      $lockable = variable_get('features_lock_mode', 'all') == 'all';
      break;

    case 'disable':
      /* @see \hook_pre_features_disable_feature() - module hook. */
      /* @see \hook_features_disable_feature() - component hook. */
      /* @see \hook_post_features_disable_feature() - module hook. */
      $restore_hook = 'features_disable_feature';
      $log_action = 'Disable';
      break;

    case 'enable':
      /* @see \hook_pre_features_enable_feature() - module hook. */
      /* @see \hook_features_enable_feature() - component hook. */
      /* @see \hook_post_features_enable_feature() - module hook. */
      $restore_hook = 'features_enable_feature';
      $log_action = 'Enable';
      break;
  }

  if (empty($items)) {
    // Drush may execute a whole chain of commands that may trigger feature
    // rebuilding multiple times during a single request. Make sure we do not
    // rebuild the same cached list of modules over and over again by setting
    // $reset to TRUE.
    // Note: this may happen whenever more than one feature will be enabled
    // in chain, for example also using features_install_modules().
    $states = features_get_component_states(array(), ($op == 'rebuild'), defined('DRUSH_BASE_PATH'));
    foreach ($states as $module_name => $components) {
      foreach ($components as $component => $state) {
        if (in_array($state, $restore_states)) {
          $items[$module_name][] = $component;
        }
      }
    }
  }

  // Invoke global pre restore hook.
  module_invoke_all('features_pre_restore', $op, $items);
  foreach ($items as $module_name => $components) {
    // If feature is totally locked, do not execute past this stage.
    if ($lockable && features_feature_is_locked($module_name)) {
      watchdog('features', 'Tried @actioning a locked @module_name, aborted.', array('@action' => $log_action, '@module_name' => $module_name));
      continue;
    }
    foreach ($components as $component) {
      // If feature is totally locked, do not execute past this stage.
      if ($lockable && features_feature_is_locked($module_name, $component)) {
        watchdog('features', 'Tried @actioning a locked @module_name / @component, aborted.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
        continue;
      }
      // Invoke pre hook.
      $pre_hook = 'pre_' . $restore_hook;
      module_invoke($module_name, $pre_hook, $component);

      if (features_hook($component, $restore_hook)) {
        // Set a semaphore to prevent other instances of the same script from
        // running concurrently.
        watchdog('features', '@actioning @module_name / @component.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
        features_semaphore('set', $component);
        features_invoke($component, $restore_hook, $module_name);

        // If the script completes, remove the semaphore and set the code
        // signature.
        features_semaphore('del', $component);
        features_set_signature($module_name, $component, NULL, __FUNCTION__ . '(' . $log_action . ')');
        watchdog('features', '@action completed for @module_name / @component.', array('@action' => $log_action, '@component' => $component, '@module_name' => $module_name));
      }

      // Invoke post hook.
      $post_hook = 'post_' . $restore_hook;
      module_invoke($module_name, $post_hook, $component);
    }
  }
  // Invoke global post restore hook.
  module_invoke_all('features_post_restore', $op, $items);
}

/**
 * Wrapper around _features_restore().
 *
 * @param string[][] $revert
 *   Module components to be reverted.
 *   If empty, all applicable feature modules will be reverted.
 *   Format: $[$module_name][] = $component
 *   E.g. $['myfeature'][] = 'field_instance'.
 */
function features_revert($revert = array()) {
  return _features_restore('revert', $revert);
}

/**
 * Wrapper around _features_restore().
 *
 * @param string[][] $rebuild
 *   Module components to be rebuilt.
 *   If empty, all applicable feature modules will be rebuilt.
 *   Format: $[$module_name][] = $component
 *   E.g. $['myfeature'][] = 'field_instance'.
 */
function features_rebuild($rebuild = array()) {
  return _features_restore('rebuild', $rebuild);
}

/**
 * Revert a single features module.
 *
 * @param string $module
 *   A features module machine name. This module must be a
 *   features module and enabled.
 */
function features_revert_module($module) {
  if (($feature = feature_load($module, TRUE)) && module_exists($module)) {
    $components = array();
    foreach (array_keys($feature->info['features']) as $component) {
      if (features_hook($component, 'features_revert')) {
        $components[] = $component;
      }
    }
    features_revert(array($module => $components));
  }
}

/**
 * Log a message, environment agnostic.
 *
 * @param string $message
 *   The message to log.
 * @param string $severity
 *   The severity of the message: status, warning or error.
 */
function features_log($message, $severity = 'status') {
  if (function_exists('drush_verify_cli')) {
    $message = strip_tags($message);
    if ($severity == 'status') {
      $severity = 'ok';
    }
    elseif ($severity == 'error') {
      drush_set_error($message);
      return;
    }
    drush_log($message, $severity);
    return;
  }
  drupal_set_message($message, $severity, FALSE);
}

/**
 * Implements hook_hook_info().
 */
function features_hook_info() {
  $hooks = array(
    'features_api',
    'features_pipe_alter',
    'features_export_alter',
    'features_export_options_alter',
  );
  return array_fill_keys($hooks, array('group' => 'features'));
}

/**
 * Change vocabularies permission, from vocab id to machine name and vice versa.
 *
 * The taxonomy module builds permission machine names from auto-increment
 * taxonomy vocabulary vids, which is not useful when exporting to features.
 *
 * On features export, these permission names are converted, replacing the vids
 * with taxonomy machine names. On import, this is reversed.
 *
 * @param string $perm
 *   A permission machine name from the real permissions system,
 *   or a modified permission machine name from a feature module.
 *   This will by modified (by reference), if it is one of:
 *   - 'edit terms in ' . $vid_or_name
 *   - 'delete terms in ' . $vid_or_name.
 * @param string $type
 *   One of 'vid' or 'machine_name'.
 *   If 'vid', vocabulary ids will be replaced by machine names.
 *   If 'machine_name', vocabulary machine names will be replaced by vids.
 *
 * @see \taxonomy_permission()
 */
function _user_features_change_term_permission(&$perm, $type = 'vid') {
  if (!module_exists('taxonomy')) {
    return;
  }
  // Export vocabulary permissions using the machine name, instead of vocabulary
  // id.
  if (strpos($perm, 'edit terms in ') !== FALSE || strpos($perm, 'delete terms in ') !== FALSE) {
    preg_match("/(?<=\040)([^\s]+?)$/", trim($perm), $voc_id);
    $vid = $voc_id[0];
    if (is_numeric($vid) && $type == 'vid') {
      if (function_exists('taxonomy_vocabulary_load')) {
        if ($voc = taxonomy_vocabulary_load($vid)) {
          $perm = str_replace($vid, $voc->machine_name, $perm);
        }
      }
    }
    elseif ($type == 'machine_name') {
      if ($voc = taxonomy_vocabulary_machine_name_load($vid)) {
        $perm = str_replace($vid, $voc->vid, $perm);
      }
    }
  }
}

/**
 * Recursively computes the difference of arrays with additional index check.
 *
 * This is a version of array_diff_assoc() that supports multidimensional
 * arrays.
 *
 * @param array $array1
 *   The array to compare from.
 * @param array $array2
 *   The array to compare to.
 *
 * @return array
 *   Returns an array containing all the values from array1 that are not present
 *   in array2.
 */
function features_array_diff_assoc_recursive(array $array1, array $array2) {
  $difference = array();
  foreach ($array1 as $key => $value) {
    if (is_array($value)) {
      if (!isset($array2[$key]) || !is_array($array2[$key])) {
        $difference[$key] = $value;
      }
      else {
        $new_diff = features_array_diff_assoc_recursive($value, $array2[$key]);
        if (!empty($new_diff)) {
          $difference[$key] = $new_diff;
        }
      }
    }
    elseif (!isset($array2[$key]) || $array2[$key] != $value) {
      $difference[$key] = $value;
    }
  }
  return $difference;
}

/**
 * Returns an array of deprecated components.
 *
 * Rather than deprecating the component directly, we look for other components
 * that supersedes the component.
 *
 * @param array[] $components
 *   (optional) An array of components.
 *   Format: $[$component] = $component_info.
 *
 * @return string[]
 *   Format: $[$deprecated_component_name] = $deprecated_component_name
 */
function features_get_deprecated($components = array()) {
  if (empty($components)) {
    $components = features_get_components();
  }
  $deprecated = array();
  foreach ($components as $component => $component_info) {
    if (!empty($component_info['supersedes'])) {
      $deprecated[$component_info['supersedes']] = $component_info['supersedes'];
    }
  }
  return $deprecated;
}

/**
 * Returns whether a feature or its component is locked.
 *
 * @param string $feature
 *   A feature module name.
 * @param string|null $component
 *   (optional) A component name, e.g. 'field_instance'.
 * @param bool $check_global_component_setting
 *   (optional) If TRUE, the module component is also considered as locked if
 *   the component is marked as locked globally.
 *
 * @return bool
 *   TRUE, if the feature or component is locked.
 */
function features_feature_is_locked($feature, $component = NULL, $check_global_component_setting = TRUE) {
  $locked = variable_get('features_feature_locked', array());
  if ($component) {
    return ($check_global_component_setting && features_component_is_locked($component)) || !empty($locked[$feature][$component]);
  }
  else {
    return !empty($locked[$feature]['_all']);
  }
}

/**
 * Returns whether a component is locked.
 *
 * @param string $component
 *   A component name, e.g. 'field_instance'.
 *
 * @return bool
 *   TRUE, if the component is locked globally.
 */
function features_component_is_locked($component) {
  return variable_get('features_component_locked_' . $component, FALSE);
}

/**
 * Locks a feature or its component.
 *
 * @param string $feature
 *   A (feature) module name.
 * @param string|null $component
 *   (optional) A component name, e.g. 'field_instance'.
 */
function features_feature_lock($feature, $component = NULL) {
  $locked = variable_get('features_feature_locked', array());
  $locked[$feature] = !empty($locked[$feature]) ? $locked[$feature] : array();
  if ($component) {
    $locked[$feature][$component] = TRUE;
  }
  else {
    $locked[$feature]['_all'] = TRUE;
  }
  variable_set('features_feature_locked', $locked);
}

/**
 * Unlocks a feature or its component.
 *
 * @param string $feature
 *   A (feature) module name.
 * @param string|null $component
 *   (optional) A component name, e.g. 'field_instance'.
 */
function features_feature_unlock($feature, $component = NULL) {
  $locked = variable_get('features_feature_locked', array());
  if ($component) {
    unset($locked[$feature][$component]);
  }
  else {
    unset($locked[$feature]['_all']);
  }
  variable_set('features_feature_locked', $locked);
}

/**
 * Sets/Returns the current language to English to ensure a proper export.
 *
 * @param \stdClass|null $language
 *   (optional) The language object to set, or NULL for English.
 *
 * @return \stdClass
 *   The previously active language object.
 *   This should be kept in a variable, to restore the original language later.
 */
function _features_export_language($language = NULL) {
  $current = $GLOBALS['language'];
  if (isset($language)) {
    $GLOBALS['language'] = $language;
  }
  elseif ($GLOBALS['language']->language != 'en') {
    // Create the language object as language_default() does.
    $GLOBALS['language'] = (object) array(
      'language' => 'en',
      'name' => 'English',
      'native' => 'English',
      'direction' => 0,
      'enabled' => 1,
      'plurals' => 0,
      'formula' => '',
      'domain' => '',
      'prefix' => '',
      'weight' => 0,
      'javascript' => '',
    );
  }
  return $current;
}

/**
 * Implements hook_features_ignore().
 */
function features_features_ignore($component) {
  // Determine which keys need to be ignored for override diff for various
  // components.
  // Value is how many levels deep the key is.
  $ignores = array();
  switch ($component) {
    case 'views_view':
      $ignores['current_display'] = 0;
      $ignores['display_handler'] = 0;
      $ignores['handler'] = 2;
      $ignores['query'] = 0;
      $ignores['localization_plugin'] = 0;
      // Views automatically adds these two on export to set values.
      $ignores['api_version'] = 0;
      $ignores['disabled'] = 0;
      break;

    case 'image':
      $ignores['module'] = 0;
      $ignores['name'] = 0;
      $ignores['storage'] = 0;
      // Various properties are loaded into the effect in image_styles.
      $ignores['summary theme'] = 2;
      $ignores['module'] = 2;
      $ignores['label'] = 2;
      $ignores['help'] = 2;
      $ignores['form callback'] = 2;
      $ignores['effect callback'] = 2;
      $ignores['dimensions callback'] = 2;
      break;

    case 'field':
      $ignores['locked'] = 1;
      break;

    case 'field_base':
      $ignores['indexes'] = 0;
      break;

    case 'taxonomy':
      $ignores['hierarchy'] = 0;
  }
  return $ignores;
}
